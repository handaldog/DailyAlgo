# 4ï¸âƒ£5ï¸âƒ£ [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] ì„¬ ì—°ê²°í•˜ê¸° </span> 

---
### ğŸ“ƒ ë¬¸ì œ ì„¤ëª…
nê°œì˜ ì„¬ ì‚¬ì´ì— ë‹¤ë¦¬ë¥¼ ê±´ì„¤í•˜ëŠ” ë¹„ìš©(costs)ì´ ì£¼ì–´ì§ˆ ë•Œ, 
ìµœì†Œì˜ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ì„¬ì´ ì„œë¡œ í†µí–‰ ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“¤ ë•Œ í•„ìš”í•œ ìµœì†Œ ë¹„ìš©ì„ return í•˜ë„ë¡ solutionì„ ì™„ì„±í•˜ì„¸ìš”.

ë‹¤ë¦¬ë¥¼ ì—¬ëŸ¬ ë²ˆ ê±´ë„ˆë”ë¼ë„, ë„ë‹¬í•  ìˆ˜ë§Œ ìˆìœ¼ë©´ í†µí–‰ ê°€ëŠ¥í•˜ë‹¤ê³  ë´…ë‹ˆë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ A ì„¬ê³¼ B ì„¬ ì‚¬ì´ì— ë‹¤ë¦¬ê°€ ìˆê³ , B ì„¬ê³¼ C ì„¬ ì‚¬ì´ì— ë‹¤ë¦¬ê°€ ìˆìœ¼ë©´ A ì„¬ê³¼ C ì„¬ì€ ì„œë¡œ í†µí–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤.

---
### ğŸ”‘ ì¶œë ¥ í˜•ì‹
![image](https://github.com/handaldog/DailyAlgo/assets/96431408/9cd41447-a0e1-4946-880b-154ee4c8ad3b)


---
### â—ï¸ í’€ì´ 
1. í¬ë£¨ìŠ¤ì¹¼ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„í–ˆë‹¤.


--- 
### ğŸ‘¨â€ğŸ’» ë°°ìš´ ì 
1. ë¨¼ì € í¬ë£¨ìŠ¤ì¹¼ê³¼ ìœ ë‹ˆì˜¨ íŒŒì¸ë“œì— ëŒ€í•´ì„œ ì´í•´ë¥¼í•œí›„ í’€ì´ë¥¼ í–ˆë‹¤.
2. ë¨¼ì € ê°€ì¥ ìµœì†Œë¹„ìš©ì´ê¸°ë•Œë¬¸ì— ê°€ì¤‘ì¹˜ì— ëŒ€í•´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•´ì•¼í•œë‹¤.
3. ê·¸ëŸ¬ë¯€ë¡œ priorityqueue + Comparableì„ ì‚¬ìš©í–ˆë‹¤. -> êµ³ì´ ì‚¬ìš©ì•ˆí•´ë„ ë¨.
4. ê·¸ë¦¬ê³  í¬ë£¨ìŠ¤ì¹¼ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œë¡œ í™•ì¸í•˜ë©´ì„œ ìµœì†Œë¹„ìš©ì„ êµ¬í–ˆë‹¤.
5. ë‚˜ì¤‘ì— í•œë²ˆë” í’€ì–´ ë³¼ ë¬¸ì œ!!
6. (ë‚˜ì¤‘ì— ì´í•´í•  ë‚´ìš©) "Arrays.sort(costs, (int[] c1, int[] c2) -> c1[2]-c2[2])"

---
### ğŸ’° ì½”ë“œ
[í¬ë£¨ìŠ¤ì¹¼ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ëª¨ë¥¼ ë•Œ]
```
import java.util.*;

class Solution {
    
    static class Edge implements Comparable<Edge>{
        int one;
        int two;
        int w;
        
        Edge(int one, int two, int w){
            this.one = one;
            this.two = two;
            this.w = w;
        }
        
        @Override 
        public int compareTo(Edge e){
            return this.w - e.w;
        }
        
            }
    
    public int solution(int n, int[][] costs) {
        int answer = 0;
        
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        
        for(int i=0;i<costs.length;i++){
            pq.offer(new Edge(costs[i][0], costs[i][1], costs[i][2]));
        }
        
        ArrayList<Integer>[] list = new ArrayList[n];
        
        for(int i=0;i<n;i++){
            list[i] = new ArrayList();
        }
        
        Edge ed = pq.poll();
            
        list.add(ed.one);
        list.add(ed.two);
        
        answer+= ed.w;
                
        while(!pq.isEmpty()){
            
            if(list.size() == n) return answer;
            
            Edge e = pq.poll();
            
            if(list.contains(e.two) && list.contains(e.one))continue;
            
            if(!list.contains(e.one)){
                list.add(e.one);
            }
            if(!list.contains(e.two)){
                list.add(e.two);
            }
            answer+= e.w;
       
            
        }
        
        return answer;
    }
    
    public static boolean cycle(){
        
    }
}

```
[í¬ë£¨ìŠ¤ì¹¼ + ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ì‚¬ìš©]
```
import java.util.*;

class Solution {
    
    static class Edge implements Comparable<Edge>{
        int one;
        int two;
        int w;
        
        Edge(int one, int two, int w){
            this.one = one;
            this.two = two;
            this.w = w;
        }
        
        @Override 
        public int compareTo(Edge e){
            return this.w - e.w;
        }
        
            }
    
    static int parent[];
    
    public int solution(int n, int[][] costs) {
        int answer = 0;
        
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        
        for(int i=0;i<costs.length;i++){
            pq.offer(new Edge(costs[i][0], costs[i][1], costs[i][2]));
        }
        
        parent = new int [n];
        
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
        
        while(!pq.isEmpty()){
            Edge e = pq.poll();
            if(find(e.one) != find(e.two)){
                answer+= e.w;
                union(e.one,e.two);
            }
        }
               
        return answer;
    }
    
    public static int find(int num){
        if(parent[num] == num)return num;
        else{
            return find(parent[num]);
        }
    }
    
    public static void union(int one, int two){
        int x = find(one);
        int y = find(two);
        
        if(x > y){
            parent[x] = y;
        }
        else{
            parent[y] = x;
        }
    }
}

```
![image](https://github.com/handaldog/DailyAlgo/assets/96431408/dc26a555-052a-429e-80fa-e0bc5f8adfda)

